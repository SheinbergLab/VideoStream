<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VideoStream Terminal</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
            background: #1e1e1e;
            color: #d4d4d4;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        #header {
            background: #2d2d30;
            padding: 10px 20px;
            border-bottom: 1px solid #3e3e42;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #header h1 {
            font-size: 16px;
            font-weight: normal;
            color: #cccccc;
        }

        #status {
            font-size: 12px;
            padding: 4px 12px;
            border-radius: 3px;
            background: #0e639c;
            color: white;
        }

        #status.disconnected {
            background: #a1260d;
        }

        #terminal {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            font-size: 14px;
            line-height: 1.5;
            user-select: text;
            cursor: text;
        }

        .output-line {
            margin: 2px 0;
            white-space: pre-wrap;
            word-wrap: break-word;
            user-select: text;
        }

        .command-line {
            color: #569cd6;
        }

        .result-line {
            color: #d4d4d4;
        }

        .error-line {
            color: #f48771;
        }

        .info-line {
            color: #608b4e;
            font-style: italic;
        }

        .warning-line {
            color: #dcdcaa;
        }

        /* Event messages styling */
        .event-line {
            color: #9cdcfe;
            opacity: 0.8;
        }

        .input-container {
            display: flex;
            align-items: center;
            margin-top: 4px;
        }

        .prompt {
            color: #569cd6;
            margin-right: 8px;
            user-select: none;
        }

        #input {
            flex: 1;
            background: transparent;
            border: none;
            color: #d4d4d4;
            font-family: inherit;
            font-size: inherit;
            outline: none;
            caret-color: #d4d4d4;
        }

        #input::selection {
            background: #264f78;
        }

        ::selection {
            background: #264f78;
            color: inherit;
        }

        ::-moz-selection {
            background: #264f78;
            color: inherit;
        }

        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }

        ::-webkit-scrollbar-track {
            background: #1e1e1e;
        }

        ::-webkit-scrollbar-thumb {
            background: #424242;
            border-radius: 5px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #4a4a4a;
        }
    </style>
</head>
<body>
    <div id="header">
        <h1>VideoStream Terminal</h1>
        <span id="status" class="disconnected">Disconnected</span>
    </div>
    
    <div id="terminal">
        <div class="info-line">VideoStream Web Terminal v1.0 - Type 'help' for commands</div>
        <div class="info-line">Connecting to WebSocket...</div>
    </div>

    <script>
        const terminal = document.getElementById('terminal');
        const statusElement = document.getElementById('status');
        
        let ws = null;
        let history = JSON.parse(localStorage.getItem('VideoStream-history') || '[]');
        let historyIndex = history.length;
        let inputElement = null;
        let requestId = 0;
        let pendingRequests = new Map();
        
        function createInputLine() {
            const container = document.createElement('div');
            container.className = 'input-container';
            
            const prompt = document.createElement('span');
            prompt.className = 'prompt';
            prompt.textContent = 'vstream> ';
            
            inputElement = document.createElement('input');
            inputElement.id = 'input';
            inputElement.type = 'text';
            inputElement.autocomplete = 'off';
            inputElement.spellcheck = false;
            
            container.appendChild(prompt);
            container.appendChild(inputElement);
            terminal.appendChild(container);
            
            inputElement.focus();
            terminal.scrollTop = terminal.scrollHeight;
            
            inputElement.addEventListener('keydown', handleKeyDown);
        }
        
        function handleKeyDown(e) {
            switch(e.key) {
                case 'Enter':
                    e.preventDefault();
                    submitCommand();
                    break;
                case 'ArrowUp':
                    e.preventDefault();
                    navigateHistory(-1);
                    break;
                case 'ArrowDown':
                    e.preventDefault();
                    navigateHistory(1);
                    break;
                case 'p':
                    if (e.ctrlKey) {
                        e.preventDefault();
                        navigateHistory(-1);
                    }
                    break;
                case 'n':
                    if (e.ctrlKey) {
                        e.preventDefault();
                        navigateHistory(1);
                    }
                    break;
                case 'c':
                    if (e.ctrlKey) {
                        e.preventDefault();
                        inputElement.value = '';
                    }
                    break;
                case 'l':
                    if (e.ctrlKey) {
                        e.preventDefault();
                        clearTerminal();
                    }
                    break;
                case 'a':
                    if (e.ctrlKey) {
                        e.preventDefault();
                        inputElement.setSelectionRange(0, 0);
                    }
                    break;
                case 'e':
                    if (e.ctrlKey) {
                        e.preventDefault();
                        const length = inputElement.value.length;
                        inputElement.setSelectionRange(length, length);
                    }
                    break;
                case 'u':
                    if (e.ctrlKey) {
                        e.preventDefault();
                        inputElement.value = '';
                    }
                    break;
                case 'k':
                    if (e.ctrlKey) {
                        e.preventDefault();
                        const cursorPos = inputElement.selectionStart;
                        inputElement.value = inputElement.value.substring(0, cursorPos);
                    }
                    break;
                case 'w':
                    if (e.ctrlKey) {
                        e.preventDefault();
                        const cursorPos = inputElement.selectionStart;
                        const beforeCursor = inputElement.value.substring(0, cursorPos);
                        const lastSpace = beforeCursor.trimEnd().lastIndexOf(' ');
                        const afterCursor = inputElement.value.substring(cursorPos);
                        inputElement.value = beforeCursor.substring(0, lastSpace + 1) + afterCursor;
                        inputElement.setSelectionRange(lastSpace + 1, lastSpace + 1);
                    }
                    break;
            }
        }
        
        function navigateHistory(direction) {
            if (history.length === 0) return;
            
            historyIndex += direction;
            historyIndex = Math.max(0, Math.min(history.length, historyIndex));
            
            if (historyIndex === history.length) {
                inputElement.value = '';
            } else {
                inputElement.value = history[historyIndex];
            }
        }
        
        function isBlockedCommand(command) {
            const normalizedCmd = command.trim().toLowerCase();
            const blockedCommands = ['exit', 'quit', 'vstream::exit', 'vstream::shutdown'];
            return blockedCommands.includes(normalizedCmd);
        }
        
        function submitCommand() {
            const command = inputElement.value.trim();
            if (!command) return;
            
            // Save to history
            if (command !== history[history.length - 1]) {
                history.push(command);
                if (history.length > 100) history.shift();
                localStorage.setItem('VideoStream-history', JSON.stringify(history));
            }
            historyIndex = history.length;
            
            // Display command
            const commandLine = document.createElement('div');
            commandLine.className = 'output-line command-line';
            commandLine.textContent = 'vstream> ' + command;
            inputElement.parentElement.replaceWith(commandLine);
            
            // Check if command is blocked
            if (isBlockedCommand(command)) {
                showWarning('Command blocked: Use browser controls to close the terminal');
                createInputLine();
                return;
            }
            
            // Send command with request ID for response matching
            if (ws && ws.readyState === WebSocket.OPEN) {
                const reqId = `req_${++requestId}`;
                ws.send(JSON.stringify({
                    cmd: 'eval',
                    script: command,
                    requestId: reqId
                }));
                pendingRequests.set(reqId, Date.now());
            } else {
                showError('Not connected to server');
                createInputLine();
            }
        }
        
        function showResult(data) {
            const resultLine = document.createElement('div');
            resultLine.className = 'output-line result-line';
            
            if (typeof data === 'object') {
                if (data.status === 'error') {
                    resultLine.className = 'output-line error-line';
                    resultLine.textContent = data.error || 'Unknown error';
                } else {
                    const result = data.result || '';
                    if (result) {
                        resultLine.textContent = result;
                    } else {
                        // Empty result - don't show a line
                        createInputLine();
                        return;
                    }
                }
            } else {
                resultLine.textContent = data;
            }
            
            terminal.appendChild(resultLine);
            createInputLine();
        }
        
        function showEvent(event) {
            const eventLine = document.createElement('div');
            eventLine.className = 'output-line event-line';
            
            let eventText = `[Event: ${event.event}]`;
            if (event.data && typeof event.data === 'object') {
                eventText += ' ' + JSON.stringify(event.data, null, 2);
            } else if (event.data) {
                eventText += ' ' + event.data;
            }
            
            eventLine.textContent = eventText;
            
            // Insert before input line if it exists
            if (inputElement && inputElement.parentElement) {
                terminal.insertBefore(eventLine, inputElement.parentElement);
            } else {
                terminal.appendChild(eventLine);
            }
            
            terminal.scrollTop = terminal.scrollHeight;
        }
        
        function showError(message) {
            const errorLine = document.createElement('div');
            errorLine.className = 'output-line error-line';
            errorLine.textContent = 'Error: ' + message;
            terminal.appendChild(errorLine);
        }
        
        function showInfo(message) {
            const infoLine = document.createElement('div');
            infoLine.className = 'output-line info-line';
            infoLine.textContent = message;
            terminal.appendChild(infoLine);
        }
        
        function showWarning(message) {
            const warningLine = document.createElement('div');
            warningLine.className = 'output-line warning-line';
            warningLine.textContent = message;
            terminal.appendChild(warningLine);
        }
        
        function clearTerminal() {
            terminal.innerHTML = '';
            showInfo('Terminal cleared');
            createInputLine();
        }
        
        function connect() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.hostname}:${window.location.port}/ws`;
            
            try {
                ws = new WebSocket(wsUrl);
                
                ws.onopen = () => {
                    statusElement.textContent = 'Connected';
                    statusElement.classList.remove('disconnected');
                    showInfo('Connected to VideoStream WebSocket');
                    
                    // Subscribe to important events (optional - can comment out)
                    ws.send(JSON.stringify({
                        cmd: 'subscribe',
                        topics: ['vstream/*', 'eyetracking/*']
                    }));
                    
                    createInputLine();
                };
                
                ws.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        
                        // Handle different message types
                        if (data.type === 'event') {
                            showEvent(data);
                        } else if (data.type === 'welcome') {
                            showInfo(`Client ID: ${data.client_id}`);
                        } else if (data.requestId) {
                            // Response to a command
                            pendingRequests.delete(data.requestId);
                            showResult(data);
                        } else {
                            // Legacy format or unknown
                            showResult(data);
                        }
                    } catch (e) {
                        // Plain text response
                        showResult(event.data);
                    }
                };
                
                ws.onerror = (error) => {
                    showError('WebSocket error');
                };
                
                ws.onclose = () => {
                    statusElement.textContent = 'Disconnected';
                    statusElement.classList.add('disconnected');
                    showInfo('Disconnected from server. Reconnecting in 3 seconds...');
                    pendingRequests.clear();
                    setTimeout(connect, 3000);
                };
                
            } catch (error) {
                showError('Failed to connect: ' + error.message);
                setTimeout(connect, 3000);
            }
        }
        
        // Start connection
        connect();
        
        // Click handler - only focus if not selecting text
        terminal.addEventListener('click', (e) => {
            const selection = window.getSelection();
            if (selection && selection.toString().length > 0) {
                return;
            }
            
            if (e.target === terminal || e.target.classList.contains('output-line')) {
                if (inputElement) inputElement.focus();
            }
        });
        
        terminal.addEventListener('mousedown', (e) => {
            if (e.target.classList.contains('output-line')) {
                e.target.addEventListener('mouseup', checkSelection, { once: true });
            }
        });
        
        function checkSelection(e) {
            const selection = window.getSelection();
            if (selection && selection.toString().length > 0) {
                e.stopPropagation();
            }
        }
    </script>
</body>
</html>
